# Development of Web-based Serial Assistant

Demo: **<https://serial.wiki-power.com/>**  
Project Repository: [**linyuxuanlin/Serial_on_Web**](https://github.com/linyuxuanlin/Serial_on_Web)

This project is based on [**web-serial-terminal**](https://github.com/rafaelaroca/web-serial-terminal) and adds [**debugout.js**](https://github.com/inorganik/debugout.js) to implement logging and exporting functions. The following are the detailed steps:

### Add `debug.js` code

```js
// save all the console.logs
function debugout() {
  var self = this;

  // OPTIONS
  self.realTimeLoggingOn = true; // log in real time (forwards to console.log)
  self.useTimestamps = false; // insert a timestamp in front of each log
  self.useLocalStorage = false; // store the output using window.localStorage() and continuously add to the same log each session
  self.recordLogs = true; // set to false after you're done debugging to avoid the log eating up memory
  self.autoTrim = true; // to avoid the log eating up potentially endless memory
  self.maxLines = 2500; // if autoTrim is true, this many most recent lines are saved
  self.tailNumLines = 100; // how many lines tail() will retrieve
  self.logFilename = "log.txt"; // filename of log downloaded with downloadLog()
  self.maxDepth = 25; // max recursion depth for logged objects

  // vars
  self.depth = 0;
  self.parentSizes = [0];
  self.currentResult = "";
  self.startTime = new Date();
  self.output = "";

  this.version = function () {
    return "0.5.0";
  };

```
/*
		USER METHODS
	*/
	// Returns the log with retrieval time and session duration
	this.getLog = function () {
		var retrievalTime = new Date();
		// If recording is off, so dev knows why they don't have any logs
		if (!self.recordLogs) {
			self.log("[debugout.js] log recording is off.");
		}
		// If using local storage, get values
		if (self.useLocalStorage) {
			var saved = window.localStorage.getItem("debugout.js");
			if (saved) {
				saved = JSON.parse(saved);
				self.startTime = new Date(saved.startTime);
				self.output = saved.log;
				retrievalTime = new Date(saved.lastLog);
			}
		}
		return (
			self.output +
			"\n---- Log retrieved: " +
			retrievalTime +
			" ----\n" +
			self.formatSessionDuration(self.startTime, retrievalTime)
		);
	};
	// Accepts optional number or uses the default for number of lines
	this.tail = function (numLines) {
		var numLines = numLines || self.tailLines;
		return self.trimLog(self.getLog(), numLines);
	};
	// Accepts a string to search for
	this.search = function (string) {
		var lines = self.output.split("\n");
		var rgx = new RegExp(string);
		var matched = [];
		// Can't use a simple Array.prototype.filter() here because we need to add the line number
		for (var i = 0; i < lines.length; i++) {
			var addr = "[" + i + "] ";
			if (lines[i].match(rgx)) {
				matched.push(addr + lines[i]);
			}
		}
		var result = matched.join("\n");
		if (result.length == 0) result = 'Nothing found for "' + string + '".';
		return result;
	};
	// Accepts the starting line and how many lines after the starting line you want
	this.getSlice = function (lineNumber, numLines) {
		var lines = self.output.split("\n");
		var segment = lines.slice(lineNumber, lineNumber + numLines);
		return segment.join("\n");
	};
	// Immediately downloads the log - for desktop browser use
	this.downloadLog = function () {
		var file = "data:text/plain;charset=utf-8,";
		var logFile = self.getLog();
		var encoded = encodeURIComponent(logFile);
		file += encoded;
		var a = document.createElement("a");
		a.href = file;
		a.target = "_blank";
		a.download = self.logFilename;
		document.body.appendChild(a);
		a.click();
		a.remove();
	};
	// Clears the log
	this.clear = function () {
		var clearTime = new Date();
		self.output = "---- Log cleared: " + clearTime + " ----\n";
		if (self.useLocalStorage) {
			// Local storage
			var saveObject = {
				startTime: self.startTime,
				log: self.output,
				lastLog: clearTime,
			};
			saveObject = JSON.stringify(saveObject);
			window.localStorage.setItem("debugout.js", saveObject);
		}
		if (self.realTimeLoggingOn) console.log("[debugout.js] clear()");
	};
	// Records a log
	this.log = function (obj) {
		// Log in real time
		if (self.realTimeLoggingOn) console.log(obj);
		// Record log
		var type = self.determineType(obj);
		if (type != null && self.recordLogs) {
			var addition = self.formatType(type, obj);
			// Timestamp, formatted for brevity
			if (self.useTimestamps) {
				var logTime = new Date();
				self.output += self.formatTimestamp(logTime);
			}
			self.output += addition;
			if (self.autoTrim) self.output = self.trimLog(self.output, self.maxLines);
			// Local storage
			if (self.useLocalStorage) {
				var last = new Date();
				var saveObject = {
					startTime: self.startTime,
					log: self.output,
					lastLog: last,
				};
				saveObject = JSON.stringify(saveObject);
				window.localStorage.setItem("debugout.js", saveObject);
			}
		}
		self.depth = 0;
		self.parentSizes = [0];
		self.currentResult = "";
	};
	/*
		METHODS FOR CONSTRUCTING THE LOG
	*/
```

The following code defines two functions for determining and formatting the type of an object. The determineType() function classifies objects of type 'object' and returns their specific type, such as 'Date', 'RegExp', 'Array', or 'Object'. The formatType() function formats the type of an object according to the specified type, recursively if necessary. If the maximum depth is reached, the function returns "... (max-depth reached)".

```javascript
switch (type) {
  case "Object":
    self.currentResult += "{\n";
    self.depth++;
    self.parentSizes.push(self.objectSize(obj));
    var i = 0;
    for (var prop in obj) {
      self.currentResult += self.indentsForDepth(self.depth);
      self.currentResult += prop + ": ";
      var subtype = self.determineType(obj[prop]);
      var subresult = self.formatType(subtype, obj[prop]);
      if (subresult) {
        self.currentResult += subresult;
        if (i != self.parentSizes[self.depth] - 1)
          self.currentResult += ",";
        self.currentResult += "\n";
      } else {
        if (i != self.parentSizes[self.depth] - 1)
          self.currentResult += ",";
        self.currentResult += "\n";
      }
      i++;
    }
    self.depth--;
    self.parentSizes.pop();
    self.currentResult += self.indentsForDepth(self.depth);
    self.currentResult += "}";
    if (self.depth == 0) return self.currentResult;
    break;
  case "Array":
    self.currentResult += "[";
    self.depth++;
    self.parentSizes.push(obj.length);
    for (var i = 0; i < obj.length; i++) {
      var subtype = self.determineType(obj[i]);
      if (subtype == "Object" || subtype == "Array")
        self.currentResult += "\n" + self.indentsForDepth(self.depth);
      var subresult = self.formatType(subtype, obj[i]);
      if (subresult) {
        self.currentResult += subresult;
        if (i != self.parentSizes[self.depth] - 1)
          self.currentResult += ", ";
        if (subtype == "Array") self.currentResult += "\n";
      } else {
        if (i != self.parentSizes[self.depth] - 1)
          self.currentResult += ", ";
        if (subtype != "Object") self.currentResult += "\n";
        else if (i == self.parentSizes[self.depth] - 1)
          self.currentResult += "\n";
      }
    }
    self.depth--;
    self.parentSizes.pop();
    self.currentResult += "]";
    if (self.depth == 0) return self.currentResult;
    break;
  case "function":
    obj += "";
    var lines = obj.split("\n");
    for (var i = 0; i < lines.length; i++) {
      if (lines[i].match(/\}/)) self.depth--;
      self.currentResult += self.indentsForDepth(self.depth);
      if (lines[i].match(/\{/)) self.depth++;
      self.currentResult += lines[i] + "\n";
    }
    return self.currentResult;
    break;
  case "RegExp":
    return "/" + obj.source + "/";
    break;
  case "Date":
  case "string":
    if (self.depth > 0 || obj.length == 0) {
      return '"' + obj + '"';
    } else {
      return obj;
    }
  case "boolean":
    if (obj) return "true";
    else return "false";
  case "number":
    return obj + "";
    break;
}
};
this.indentsForDepth = function (depth) {
var str = "";
for (var i = 0; i < depth; i++) {
  str += "\t";
}
return str;
};
this.trimLog = function (log, maxLines) {
var lines = log.split("\n");
if (lines.length > maxLines) {
  lines = lines.slice(lines.length - maxLines);
}
return lines.join("\n");
};
this.lines = function () {
return self.output.split("\n").length;
};
// calculate testing time
this.formatSessionDuration = function (startTime, endTime) {
var msec = endTime - startTime;
var hh = Math.floor(msec / 1000 / 60 / 60);
var hrs = ("0" + hh).slice(-2);
msec -= hh * 1000 * 60 * 60;
var mm = Math.floor(msec / 1000 / 60);
var mins = ("0" + mm).slice(-2);
msec -= mm * 1000 * 60;
var ss = Math.floor(msec / 1000);
var secs = ("0" + ss).slice(-2);
msec -= ss * 1000;
return "---- Session duration: " + hrs + ":" + mins + ":" + secs + " ----";
};
this.formatTimestamp = function (timestamp) {
var year = timestamp.getFullYear();
var date = timestamp.getDate();
var month = ("0" + (timestamp.getMonth() + 1)).slice(-2);
var hrs = Number(timestamp.getHours());
var mins = ("0" + timestamp.getMinutes()).slice(-2);
var secs = ("0" + timestamp.getSeconds()).slice(-2);
return (
  "[" +
  year +
  "-" +
  month +
  "-" +
  date +
  " " +
  hrs +
  ":" +
  mins +
  ":" +
  secs +
  "]: "
);
};
this.objectSize = function (obj) {
var size = 0,
  key;
for (key in obj) {
  if (obj.hasOwnProperty(key)) size++;
}
return size;
};
```

```
/*
	START/RESUME LOG
*/
if (self.useLocalStorage) {
  var saved = window.localStorage.getItem("debugout.js");
  if (saved) {
    saved = JSON.parse(saved);
    self.output = saved.log;
    var start = new Date(saved.startTime);
    var end = new Date(saved.lastLog);
    self.output += "\n---- Session end: " + saved.lastLog + " ----\n";
    self.output += self.formatSessionDuration(start, end);
    self.output += "\n\n";
  }
}
self.output += "---- Session started: " + self.startTime + " ----\n\n";
}
```

### Add download log button

Add the following code after the `<button id="SerialConnectButton" type="button" disabled>Connect</button>` statement:

```html
<button onclick="bugout.downloadLog();">Download Log</button>
```

### Call object

Add the following code in the `<script>`:

```html
var bugout = new debugout();
```

### Output log

Add the following code after `term.write(chunk);`:

```html
bugout.log(chunk);
```

## References and Acknowledgements

- [rafaelaroca/web-serial-terminal](https://github.com/rafaelaroca/web-serial-terminal)
- [inorganik/debugout.js](https://github.com/inorganik/debugout.js)
- [onclick event](https://www.w3schools.com/jsref/event_onclick.asp)
- [How to read and write txt files in js? (Curve rescue chapter)](https://www.cnblogs.com/simuhunluo/p/8109429.html)
- [Finally found you! How to save front-end console.log logs as files?](https://segmentfault.com/a/1190000009426931)

> Original: <https://wiki-power.com/>  
> This post is protected by [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by/4.0/deed.en) agreement, should be reproduced with attribution.

> This post is translated using ChatGPT, please [**feedback**](https://github.com/linyuxuanlin/Wiki_MkDocs/issues/new) if any omissions.